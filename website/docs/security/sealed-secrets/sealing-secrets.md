---
title: "Sealing your Secrets"
sidebar_position: 70
---

Let's delete the database-credentials Secret and Pod resources that was created earlier in this module and deployed to the secure-secrets namespace in the cluster. Once this operation is completed, the only Secret that should exist in that namespace will be that of the token generated by Kubernetes for the default service account associated with the secure-secrets namespace.

```bash
$ kubectl delete pod pod-variable pod-volume -n secure-secrets 
$ kubectl delete secret database-credentials -n secure-secrets
$ kubectl get secret -n secure-secrets

NAME                  TYPE                                  DATA   AGE
default-token-v9jdr   kubernetes.io/service-account-token   3      5h28m
```

Let's generate a Secret with base64 encoded value for username and password keys in a file `secret.yaml` is as follows:

```bash
$ mkdir -p ~/environment/secrets
$ cd ~/environment/secrets
$ kubectl kustomize /workspace/modules/security/sealed-secrets > secret.yaml
```

The above commands will generate a `secret.yaml` file with the following content

```yaml
apiVersion: v1
data:
  password: VHJ1NXROMCE=
  username: YWRtaW4=
kind: Secret
metadata:
  name: database-credentials
  namespace: secure-secrets
type: Opaque
```

Now, letâ€™s create SealedSecret YAML manifests with kubeseal.

:::note
Please make sure that there is an inbound rule added to the worker nodes security group allowing port 8080 from the security group associated with your EKS cluster. This rule ensures that the API server can communicate with the sealed-secret on port 8080.
:::

```bash test=false
$ cd ~/environment/secrets
$ kubeseal --format=yaml < secret.yaml > sealed-secret.yaml
```

Alternatively, the public key can be fetched from the controller and use it offline to seal your Secrets

```bash test=false
$ kubeseal --fetch-cert > public-key-cert.pem
$ kubeseal --cert=public-key-cert.pem --format=yaml < secret.yaml > sealed-secret.yaml
```

It will create a sealed-secret with the following content:

```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  creationTimestamp: null
  name: database-credentials
  namespace: secure-secrets
spec:
  encryptedData:
    password: AgBocs(...)5eROg==
    username: AgAImH(...)cEGA==
  template:
    data: null
    metadata:
      creationTimestamp: null
      name: database-credentials
      namespace: secure-secrets
    type: Opaque
```

Let's deploy the SealedSecret to your EKS cluster:

```bash test=false
$ kubectl apply -f sealed-secret.yaml

```

The controller logs shows that it picks up the SealedSecret custom resource that was just deployed, unseals it to create a regular Secret.

```bash test=false
$ kubectl logs sealed-secrets-controller-77747c4b8c-snsxp -n kube-system

2022/10/18 11:53:51 Updating secure-secrets/database-credentials
2022/10/18 11:53:51 Event(v1.ObjectReference{Kind:"SealedSecret", Namespace:"secure-secrets", Name:"database-credentials", UID:"6a79121f-f863-440d-bd2a-37781921c4e6", APIVersion:"bitnami.com/v1alpha1", ResourceVersion:"188137", FieldPath:""}): type: 'Normal' reason: 'Unsealed' SealedSecret unsealed successfully
```

Verify that the `database-credentials` Secret unsealed from the SealedSecret was deployed by the controller to the secure-secrets namespace.

```bash test=false
$ kubectl get secret -n secure-secrets database-credentials

NAME                   TYPE     DATA   AGE
database-credentials   Opaque   2      4m24s
```

Let's redeploy the pod that reads from the above Secret and verify that the keys have been exposed as environment variables with the correct literal values.

```bash
$ kubectl apply -f /workspace/modules/security/sealed-secrets/pod-variable.yaml

$ kubectl wait -n secure-secrets pod/pod-variable --for=condition=Ready
$ kubectl logs -n secure-secrets pod-variable

DATABASE_USER = admin
DATABASE_PASSWROD = Tru5tN0!
```

The **sealed-secret.yaml** which is a SealedSecret resource is safe to be stored in a Git repository along with YAML manifests pertaining to other Kubernetes resources such as DaemonSets, Deployments, ConfigMaps etc. deployed in the cluster. You can then use a GitOps workflow to manage the deployment of these resources to your cluster. The YAML file, secret.yaml, that is a Secret resource may be deleted because it is never used in any subsequent workflows.
